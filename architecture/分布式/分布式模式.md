## Quorum

+ 每个决策都需要大多数服务器同意，避免两组服务器各自独立做出决策。

+ 集群收到一次更新，在集群中的大多数节点确认了这次更新之后，集群才算是确认了这次更新。我们将这个数量称之为 Quorum。
    + Quorum = n/2 + 1

+ 所有的共识实现都是基于 Quorum 的，比如，Zab、Raft、Paxos

+ 其吞吐量会随着集群规模的变大而降低

## 一致性内核（Consistent Core）
+ 维护一个较小的内核，为大规模数据集群提供更强的一致性，这样，可以在无需实现基于 Quorum 算法的前提下协调服务器行为。
+ 实现一个三五个节点的小集群，提供线性一致性的保证，同时支持失效容忍
    + 元数据集群
        + 存储元数据
            + 分组成员
            + 跨服务器的任务分布
+ 客户端只与内核中的leader交互

## 追随者读取（Follower Reads）

+ 使用领导者和追随者模式时，如果有太多请求发给领导者，它可能会出现过载。此外，在多数据中心的情况下，客户端如果在远程的数据中心，向领导者发送的请求可能会有额外的延迟。

+ 当写请求要到领导者那去维持一致性，只读请求就会转到最近的追随者。当客户端大多都是只读的.
    + 从追随者服务器上读取信息只能用于“可以容忍稍旧的值”的情况

## 单一 Socket 通道（Single Socket Channel）

+ 有序
    + 通过使用单一的 TCP 连接，维护发送给服务器请求的顺序。

+ 确保在leader和各个follower之间的消息保持有序，如果有消息丢失，需要重试机制

+ 节点一旦打开连接，就不会关闭，持续从中读取新的请求。节点为每个连接准备一个专用的线程去读取写入请求。如果使用的是非阻塞 IO，那就不需要为每个连接准备一个线程。
    + 通道一直存活
        + 连接有超时(避免故障导致永久阻塞)，通过心跳避免超时
            + 超时时间设置成心跳间隔的 10 倍

## 租约（Lease）

+ 集群节点需要对特定的资源进行排他性访问。但是，节点可能会崩溃；他们会临时失联，经历进程暂停。在这些出错的场景下，它们不应该无限地保持对资源的访问。

## tips

+ 线性一致性
+ 共识算法

## ref
+ [patterns-of-distributed-systems](https://github.com/dreamhead/patterns-of-distributed-systems)
+ [Patterns of Distributed Systems](https://martinfowler.com/articles/patterns-of-distributed-systems)
