## Transaction

+ 为了简化应用编程模型而创建的
    + safety guarantees

+ 隔离级别
    + read committed
    + snapshot isolation
    + serializability

+ ACID
    + Atomicity(*)
        + all-or-nothing
    + Consistency
    + Isolation(*)
        + 解决并发问题(race conditions/竞争条件)
        + 隔离级别
            + 可串行(serializable)
                + 实现
                    + 一次执行一个事务，没有并发
                        + 单个线程上按顺序一次只执行一个事务
                            + 当事务需要访问的所有数据都在内存中时，事务处理的执行速度要比等待数据从磁盘加载时快得多
                            + 长时间运行的分析查询通常是只读的，因此它们可以在串行执行循环之外的一致快照（使用快照隔离）上运行。
                        + redis
                            + 具有单线程串行事务处理的系统不允许交互式的多语句事务
                                + 应用和数据库之前数据传来传去
                                + 数据应该预先都在内存中，不需要磁盘或网络I/O
                        + 分区
                            + 个事务只需要在单个分区中读写数据
                                + 对于需要访问多个分区的任何事务，数据库必须在触及的所有分区之间协调事务。存储过程需要跨越所有分区锁定执行，以确保整个系统的可串行性。
                        + 反缓存（anti-caching）
                            + 事务需要访问不在内存中的数据，最好的解决方案可能是中止事务，异步地将数据提取到内存中，同时继续处理其他事务，然后在数据加载完毕时重新启动事务
                        + 短小事务
                            + 一个事务不会跨越多个请求。一个新的 HTTP 请求开始一个新的事务
                    + 2PL,two-phase locking(两阶段锁定)
                        + 只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要 独占访问（exclusive access） 权限
                            + 如果事务 A 读取了一个对象，并且事务 B 想要写入该对象，那么 B 必须等到 A 提交或中止才能继续
                            + 如果事务 A 写入了一个对象，并且事务 B 想要读取该对象，则 B 必须等到 A 提交或中止才能继续
                        + 写会阻塞其他写和读
                        + 是一种悲观并发控制机制（pessimistic）
                        + lock
                            + 共享模式（shared mode/独占模式（exclusive mode）
                                + 可能会死锁(deadlock)
                            + 谓词锁（predicate lock
                            + 索引范围锁（index-range locking
                    + 乐观并发控制,serializable snapshot isolation（可串行化快照隔离,SSI）
                        + 它使用乐观的方法，允许事务执行而无需阻塞。当一个事务想要提交时，它会进行检查，如果执行不可串行化，事务就会被中止。

            + 非串行的(nonserializable),弱隔离级别
                + 只读事务在并发写入时可以看到:
                    + 读已提交(Read committed)
                        + 读数据库时只能读取已提交的数据(没有dirty reads)
                            + 防止脏写
                                + 行锁(row-level lock)
                                    + 只有等持有锁的事务提交时，后续写事务才能获取锁写入数据
                        + 写数据库时，只能覆盖已写入的数据(没有dirty writes)
                            + 防止脏读
                                + 数据库会同时持有旧值和新值(两个版本就够了，MVCC需要多个版本)，新值提交前只会返回旧值
                        + 未解决:
                            + nonrepeatable read
                                + 暂时性的，刷新页面可以解决
                    + 快照隔离(snapshot isolation)
                        + 其他叫法 serializable,repeatable read
                        + 需要单调递增的 事务ID
                            + 分布式序列号生成器
                                + Snowflake
                                + 时间戳作为序号
                                    + Spanner
                                    + 需要保证精度
                        + 事务从数据库的一致快照(consistent snapshot)读取数据
                            + 事务读取事务开始时的数据（中间数据被其他事务改变，也只会读取旧数据）
                            + 写需要锁，读不需要（读不阻塞写，写不阻塞读）
                            + 数据库维护单个对象的多个版本,多版本并发控制（MVCC, multi-version concurrency control）
                                + 用MVCC实现read committed
                                + MVCC的索引
                                    + 所有版本都添加索引，查询时过滤不可见对象
                                    + 仅追加的B树，每个写入事务都会创建一个新的B树
                            + 对整个事务使用相同快照
                                + 读已提交是对每个查询使用单独的快照
                            + 每个事务都有一个唯一id,任何操作都会被记录到行中的created_by,deleted_by
                                + 事务id决定他可以看到哪些对象
                                + UPDATE 操作在内部翻译为 DELETE 和 INSERT
                                    + 不原地更新对象
                        + 解决了nonrepeatable read
                            + 对长时间运行的读查询(备份，分析)很有用
                                + 不会造成分析错误
                        + 未解决：写入偏差和幻读
                + 两个事务并发写问题
                <!-- lost update, (read-update-write)序列事务会产生(多个事务更新同一个对象) -->
                    + 原子写(update ... set 一般数据库提供)
                        + 使(read-update-write)顺序发生
                            + 游标稳定性（cursor stability）
                                + 原子操作在读取对象时会获取其上的排它锁，更新完之前没有事务可以读取他
                            + 单线程上执行
                    + 显示锁定
                        + 应用实现
                    + 自动检查丢失的更新
                        + (read-update-write)并行，如果事务管理器检查到lost update，则终止事务并重试(read-update-write)
                    + CAS(Compare and set)
                        + 不提供事务的数据库的一种原子操作
                    + 冲突解决
                        + 锁和 CAS 操作假定只有一个最新的数据副本
                            + 多主或无主复制的数据库通常允许多个写入并发执行，并异步复制到副本上，因此无法保证只有一个最新数据的副本
                            + 锁或 CAS 操作的技术不适用于这种情况
                        + 允许写入多个冲突版本的值，在应用中合并冲突(Git中的冲突)
                    + 复制
                        + 最后写入胜利（LWW
                <!-- 写入偏斜与幻读-->
                    + 写偏差
                        + (两个事务读取相同的对象，然后更新其中一些对象，不同事务可以更新不同对象) 例子：会议室预定
                        + 解决
                            + 涉及多个对象，原子操作不起作用
                            + `FOR UPDATE` 锁定返回的行用于更新
                            + 串行化
                            + huan'du
                    + 幻读
                        + 一个事务中的写入改变另一个事务的搜索查询的结果
                        + 快照隔离避免了只读查询中幻读
                        + 读会导致特别棘手的写入偏差情况
                        + 物化冲突（materializing conflicts）,一般最后的手段
                            + 没有对象可以加锁
                                + 可以人为地在数据库中引入一个锁对象

                    
    + Durability

+ BASE
    + Basically Available
    + Soft State
    + Eventual consistency

    
+ 多对象写入
    + multi-object transaction
        + 许多分布式数据存储已经放弃了多对象事务，因为多对象事务很难跨分区实现

+ 单对象写入
    + 一个大对象写了一半，网络断开...
        + 在文档数据模型中，需要一起更新的字段通常在同一个文档中，这被视为单个对象
    + 存储引擎一般对单节点单对象提供原子性和隔离性
        + 原子性
            + write-ahead log
            + CAS,compare-and-set(值没被其他并发改过时，才允许执行写操作) (轻量级事务)
            + atomic increment
        + 隔离性
            + 锁，每次只允许一个线程访问对象



## tips
+ 没有原子性，错误处理就要复杂得多，缺乏隔离性，就会导致并发问题
+ 2PC, two-phase commit
+ Heisenbug(偶然发生的瞬时bug)
+ Bohrbugs(确定性问题)
+ 并发问题
    + 写偏差（两个事务读取相同的对象，然后更新其中一些对象，不同事务可以更新不同对象）
    + 脏写，lost update（多个事务更新同一个对象）

+ 脏读：一个客户端读取到另一个客户端尚未提交的写入。读已提交 或更强的隔离级别可以防止脏读。
+ 脏写：一个客户端覆盖写入了另一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写。
+ 读取偏差（不可重复读）： 在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。快照隔离 经常用于解决这个问题，它允许事务从一个特定时间点的一致性快照中读取数据。快照隔离通常使用 多版本并发控制（MVCC） 来实现。
+ 更新丢失： 两个客户端同时执行 读取 - 修改 - 写入序列。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致数据丢失。快照隔离的一些实现可以自动防止这种异常，而另一些实现则需要手动锁定（SELECT FOR UPDATE）。
+ 写偏差： 一个事务读取一些东西，根据它所看到的值作出决定，并将该决定写入数据库。但是，写入时，该决定的前提不再是真实的。只有可串行化的隔离才能防止这种异常。
+ 幻读：事务读取符合某些搜索条件的对象。另一个客户端进行写入，影响搜索结果。快照隔离可以防止直接的幻像读取，但是写入偏差上下文中的幻读需要特殊处理，例如索引范围锁定。

+ 租约(lease)
    + 带超时的锁
    + 任一时刻只有一个节点可以持有租约
    + leader获取其他follower的lease
        + 周期性的续约
    + 依赖同步时间
+ 网络时间协议（NTP）

+ GC
    + 导致响应延期，lease超时

+ 防护（fencing）
    + 防护令牌（fencing token）
        + 每次授予锁定时都会增加数字，服务器如果处理过高令牌编号操作则会拒绝低令牌编号操作
        + Zookeeper做锁定服务时，可将事务标识 zxid 或节点版本 cversion 用作防护令牌（单调递增）

+ 同步
    + 时序
        + 时钟

## ref
+ [第七章：事务](http://ddia.vonng.com/#/ch7)