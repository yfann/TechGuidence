# leveldb cache

+ LRUCache
    + cache：来缓存已经被打开的sstable文件句柄以及元数据
    + bcache：来缓存被读过的sstable中dataBlock的数据
    
+ 当一个sstable文件需要被打开时，首先从cache中寻找是否已经存在相关的文件句柄，若存在则无需重复打开；若不存在，则从打开相关文件，并将（1）indexBlock数据，（2）metaIndexBlock数据等相关元数据进行预读

+ 读热数据时在Cache中命中

## LRU（Least Recently Used）Cache 
+ 一种缓存策略，它用于在存储空间有限的情况下高效地管理数据，确保缓存中始终保留最近使用的数据，同时淘汰最久未使用的数据。
+ 实现：
    + 哈希表（HashMap）：用于 O(1) 时间复杂度快速查找缓存中的数据。
    + 双向链表（Doubly Linked List）：用于维护数据的访问顺序，最近使用的数据移动到链表头部，最久未使用的数据在链表尾部，方便 O(1) 时间复杂度进行删除操作。

## dynamic-sized nonblocking hash table
+ resize
    + 当hash表的数据量增大时，为了保证这些操作仍然保有较为理想的操作效率，需要对hash表进行resize，即改变hash表中bucket的个数，对所有的数据进行重散列。
        + 一个hash表通常由若干个bucket组成，每一个bucket中会存储若干条被散列至此的数据项
            + bucket容量有限（<=32）
        + 当hash表进行resize时，需要将“旧”桶中的数据读出，并且重新散列至另外一个“新”桶中。
            + 这个过程需要是个原子操作
    + resize的过程中不阻塞其他并发的读写请求。

+ 扩张时机
    + 整个cache中，数据项（node）的个数超过预定的阈值（默认初始状态下哈希桶的个数为16个，每个桶中可存储32个数据项，即总量的阈值为哈希桶个数乘以每个桶的容量上限）；
    + 当cache中出现了数据不平衡的情况。当某些桶的数据量超过了32个数据，即被视作数据发生散列不平衡。当这种不平衡累积值超过预定的阈值（128）个时，就需要进行扩张；

+ 扩张过程
    + 计算新哈希表的哈希桶个数（扩大一倍）；
    + 创建一个空的哈希表，并将旧的哈希表（主要为所有哈希桶构成的数组）转换一个“过渡期”的哈希表，表中的每个哈希桶都被“冻结”；
    + 后台利用“过渡期”哈希表中的“被冻结”的哈希桶信息对新的哈希表进行内容构建；

+ 哈希表扩张过程中，最小的封锁粒度为哈希桶级别。