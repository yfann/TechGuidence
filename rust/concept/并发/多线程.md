# rust线程


+ 线程可以使用闭包
+ 线程结束
    + main线程结束，程序就会结束，各个子线程也将被强行终止
    + 非main的线程结束，其子线程会继续执行直到结束


## thread::spawn
+ `join()`会阻塞当前线程，直到子线程结束
```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..5 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap(); //加入主线程

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

+ 线程中`move`
    + 转移变量所有权到线程中
```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];
    //不转移所有权会报错，线程执行不确定性，可以会引用空变量
    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();

    // 下面代码会报错borrow of moved value: `v`
    // println!("{:?}",v);
}
```

+ Barrier
    + 可以使用 Barrier 让多个线程都执行到某个点后，才继续一起往后执行
```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let mut handles = Vec::with_capacity(6);
    let barrier = Arc::new(Barrier::new(6));//

    for _ in 0..6 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!("before wait");
            b.wait();// 6个线程都到达后，继续往下执行
            println!("after wait");
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

+ 线程局部变量(Thread Local Variable)
```rust
use std::cell::RefCell;

struct Foo;
impl Foo {
    thread_local! {
        static FOO: RefCell<usize> = RefCell::new(0);
    }
}

fn main() {
    Foo::FOO.with(|x| println!("{:?}", x));
}
```
+ Mutex
+ Once 只被执行一次
    + call_once

## 多线程共享
+ Arc智能指针，可以使同一份数据被多个线程move(所有权不会冲突)
    + 配合Mutex确保线程安全





## Barrier
+ 多个线程都执行到某个点后，才继续一起往后执行
```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let mut handles = Vec::with_capacity(6);
    let barrier = Arc::new(Barrier::new(6));

    for _ in 0..6 {
        let b = barrier.clone();
        handles.push(thread::spawn(move|| {
            println!("before wait");
            b.wait();
            println!("after wait");
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

## 线程间消息传递
+ 可以实现线程的同步
    + 消息传递来控制不同线程间的执行次序
+ `let (tx, rx) = mpsc::channel();`
    + multiple producer, single consumer
+ mpmc(多发多收)
    + crossbeam-channel
    + flume

## 共享内存
+ 实现同步
+ Mutex<T>
    + m.lock()
        + 返回智能指针
            + MutexGuard<T>
                + 超出作用域会自动drop()
    + 互斥锁
    + 多线程排队访问内存
+ Arc<T>
    + 线程安全
        + `let counter = Arc::new(Mutex::new(0));`
            + 保证Mutex可以被多线程使用
+ RwLock
    + 多读情况不加锁
    + 写时加锁

+ 其他锁
    + parking_lot
    + spin

+ Condition Variables
    + 可以让线程挂起，直到某个条件发生后再继续执行

+ Semaphore
    + 控制当前正在运行的任务最大数量


## 原子类型
+ 原子指的是一系列不可被 CPU 上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核 CPU 下，当某个 CPU 核心开始运行原子操作时，会先暂停其它 CPU 内核对内存的操作，以保证原子操作不会被其它 CPU 内核所干扰
    + 由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多
    + 无锁类型
    + 内部使用CAS循环(CAS 全称是 Compare and swap, 它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值，如果相等，则将其修改为新的值)
        + 荏苒需要等待

+ 可以作为全局变量
    + `static R: AtomicU64 = AtomicU64::new(0);`

+ 内存顺序
    + Ordering::Relaxed

+ 使用场景
    + 无锁(lock free)数据结构
    + 全局变量，例如全局自增 ID, 在后续章节会介绍
    + 跨线程计数器，例如可以用于统计指标

## tips
+ 1:1线程模型
    + 程序内部线程和程序占用的操作系统线程一一对应
    + rust
+ M:N线程模型
    + 程序内实现了协程
    + Go
+ tokio
    + Rust的M:N线程模型
+ 多线程中闭包的变量通常要move
    + 新线程的闭包必须拥有其所用变量的所有权，避免数据竞争和悬垂引用等问题。
+ Rc<T>/RefCell<T>用于单线程内部可变性， Arc<T>/Mutex<T>用于多线程内部可变性。