## nodejs invterview

+ 请解释一下 Node.js 的事件驱动（Event-driven）和非阻塞（Non-blocking）的特性是什么，并解释它们在 Node.js 中的作用。
```js

// Node.js 是一个基于事件驱动和非阻塞的 JavaScript 运行时环境。它的事件驱动特性意味着它使用了事件循环机制，通过触发和处理事件来驱动程序的执行流程。非阻塞特性则指出 Node.js 在执行 I/O 操作时不会阻塞后续代码的执行，而是采用异步的方式进行处理。

// 事件驱动的特性使得 Node.js 能够高效地处理大量并发请求。它使用单线程的事件循环机制来处理请求和响应，避免了为每个请求创建新的线程所带来的开销。通过事件循环，Node.js 可以同时处理多个请求，并在请求完成时触发相应的回调函数，使得代码能够以非阻塞的方式执行。

// 非阻塞的特性使得 Node.js 在执行 I/O 操作（如文件读写、网络请求等）时能够保持高效率。当执行一个 I/O 操作时，Node.js 不会等待操作完成，而是继续执行后续代码。一旦操作完成，它会触发相应的回调函数来处理结果。这种异步的处理方式能够充分利用 CPU 的处理能力，提高系统的吞吐量。

// 通过事件驱动和非阻塞的特性，Node.js 可以构建高性能的网络应用和服务器，能够处理大量并发请求，并且在 I/O 密集型的场景中表现出色。
```

+ 请解释一下 Node.js 中的模块系统是什么，以及常用的模块加载方法有哪些？
```js
// Node.js 的模块系统是一种用于组织和复用代码的机制。它允许将相关功能的代码组织到独立的模块中，以便于管理和维护。在 Node.js 中，每个文件都被视为一个独立的模块，可以通过模块系统进行加载和使用。

// 常用的模块加载方法有以下几种：

// require()：是 Node.js 中最常用的模块加载方法。通过 require() 函数可以引入其他模块，并将模块的导出内容作为返回值使用。例如：const fs = require('fs'); 表示引入 Node.js 的文件系统模块。

// module.exports 和 exports：这是定义和导出模块内容的方式。使用 module.exports 可以将一个对象、函数或变量作为整个模块的导出内容，而使用 exports 对象可以将多个成员添加到模块的导出内容中。

// module.js
module.exports = {
  foo: 'bar'
};

// main.js
const myModule = require('./module.js');
console.log(myModule.foo);  // 输出：'bar'
```

+ require的加载机制


+ 请解释一下 Node.js 的事件循环（Event Loop）机制是如何工作的。
```js
// Node.js 的事件循环是一种用于处理事件和回调函数的机制，它是实现非阻塞 I/O 的核心。以下是 Node.js 事件循环的工作过程：

// + 事件循环开始时，Node.js 会首先执行同步任务，例如处理模块加载、执行主模块代码等。同步任务执行完毕后，进入事件循环的轮询阶段。

// + 轮询阶段中，Node.js 会检查是否有待处理的异步 I/O 请求或定时器等。如果没有，则等待直到有事件到来。

// + 当有事件到来时，事件循环会将事件添加到事件队列中，并触发相应的回调函数。例如，当一个异步操作完成时，会将其回调函数添加到事件队列中等待执行。

// + 事件循环在轮询阶段检查到事件队列有待处理的事件时，会依次取出事件并执行对应的回调函数。如果一个回调函数执行过程中触发了其他异步操作，那么这些异步操作的回调函数会被添加到事件队列中等待执行。

// + 当事件队列中的所有回调函数执行完毕后，事件循环会检查是否有被设定的定时器到达时间，如果有，则执行相应的定时器回调函数。

// + 重复上述步骤，不断地轮询事件队列和定时器，直到程序退出或调用 process.exit()。

// 通过事件循环的机制，Node.js 能够以高效的方式处理大量并发请求和异步操作。它能够将耗时的 I/O 操作转化为异步任务，在等待 I/O 结果的过程中不会阻塞后续代码的执行，从而提高了系统的性能和吞吐量。
```
+ Node.js 中有多少种 API 函数 ？
```js
// 有两种类型的 API 函数：

// 异步、非阻塞函数：主要是 I/O 操作，可以从主循环中分叉出来。
// 同步的、阻塞的函数 ：主要是影响在主循环中运行的进程的操作。
```

+ Node.js 中的 fork 是什么
```js
// 通常，fork 用于生成子进程。
// 在 node 中，它用于创建一个新的 v8 引擎实例来运行多个 worker 来执行代码。
```


## tips
+ 为什么 Node.js 是单线程的 
    + 如何处理并发
```js
// Node.js 在底层采用了单线程模型。它使用了事件驱动和非阻塞 I/O 的方式来处理请求和执行代码，但并不是真正意义上的多线程。

// 在 Node.js 中，主线程（通常称为事件循环线程）负责处理请求、事件和回调函数的执行。这个线程是单线程的，只有一个主线程在执行 JavaScript 代码。这个线程通过事件循环机制，以非阻塞的方式处理请求和回调函数，从而实现高效的并发处理。

// 尽管主线程是单线程的，但 Node.js 通过利用底层的 libuv 库，实现了多线程的效果。libuv 负责管理 I/O 操作，它使用了线程池来处理一些耗时的 I/O 操作，如文件读写和网络请求。这样可以将这些耗时的操作委托给线程池中的其他线程去执行，主线程则可以继续处理其他的请求和回调函数，从而提高了系统的并发能力。

// 需要注意的是，尽管 Node.js 在底层使用了多线程的方式处理某些 I/O 操作，但对于 JavaScript 代码执行和应用程序逻辑的部分，仍然是单线程的。这意味着在编写 Node.js 应用程序时，需要避免长时间运行的阻塞操作，以充分利用事件循环的特性和非阻塞的优势。
```
+ 回调地狱
+ V8的垃圾回收
    + 内存泄漏

+ 微任务
+ 宏任务

## ref
+ [NodeJS有难度的面试题，你能答对几个？](https://juejin.cn/post/6844903951742025736)