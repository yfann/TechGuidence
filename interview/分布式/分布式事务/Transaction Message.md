
## 基于MQ的Transaction Message
+ Transaction Message：能够支持狭义的分布式事务. 基于消息队列组件中半事务消息以及轮询检查机制，保证了本地事务和消息生产两个动作的原子性，但不具备事务的逆向回滚能力

+ 投递到 MQ 中的消息能至少被下游消费者 consumer 消费到一次(at least once)
    + 下游的 consumer 还需要基于消息的唯一键执行幂等去重操作，在 at least once 的基础上过滤掉重复消息，最终达到 exactly once 的语义
    
+ 分布式事务: 事务流程中包含需要在服务 A 中执行的动作 I 以及需要在服务 B 中执行的动作 II
    1. 以服务 A 作为 MQ 生产方 producer，服务 B 作为 MQ 消费方 consumer
    2. 服务 A 首先在执行动作 I，执行成功后往 MQ 中投递消息，驱动服务 B 执行动作 II
    3. 服务 B 消费到消息后，完成动作 II 的执行

+ 弊端：
    + 服务 B 消费到消息执行动作 II 可能发生失败，即便依赖于 MQ 重试也无法保证动作一定能执行成功，此时缺乏令服务 A 回滚动作 I 的机制. 因此很可能出现动作 I 执行成功，而动作 II 执行失败的不一致问题
        + 无解
    + 在这个流程中，服务 A 需要执行的操作有两步：（1）执行动作 I；（2）投递消息. 这两个步骤本质上也无法保证原子性，即可能出现服务 A 执行动作 I 成功，而投递消息失败的问题.

+  RocketMQ 中 TX Msg（事务消息）能保证我们做到在本地事务执行成功的情况下，后置的投递消息操作能以接近百分之百的概率被发出
    + 生产方 producer 首先向 RocketMQ 生产一条半事务消息，此消息处于中间态，会暂存于 RocketMQ 不会被立即发出
    + producer 执行本地事务
    + 如果本地事务执行成功，producer 直接提交本地事务，并且向 RocketMQ 发出一条确认消息
    + 如果本地事务执行失败，producer 向 RocketMQ 发出一条回滚指令
    + 倘若 RocketMQ 接收到确认消息，则会执行消息的发送操作，供下游消费者 consumer 消费
    + 倘若 RocketMQ 接收到回滚指令，则会删除对应的半事务消息，不会执行实际的消息发送操作
    + 此外，在 RocketMQ 侧，针对半事务消息会有一个轮询任务，倘若半事务消息一直未收到来自 producer 侧的二次确认，则 RocketMQ 会持续主动询问 producer 侧本地事务的执行状态，从而引导半事务消息走向终态


