## 分布式锁
+ 当多个独立进程（服务实例、Worker、系统）可能并发访问同一份业务资源，而它们之间没有共享锁机制时，就需要分布式锁。

+ 支持排他性操作的中间件都可以实现分布式锁
    + Redis
    + ZooKeeper
    + Nacos
    + MySQL

+ Redis实现分布式操作
    + 加锁： SETNX key1=value1 （SETNX, SET if Not eXists）
        + 成功返回1
        + 失败时处理
            + 循环轮询（Spin Lock）
            + 事件监听
                + 加锁失败的client可以订阅 key1的删除事件
                    + Redis pub/sub
                    + keyspace notification
    + 释放锁：DEL key1
        + 释放锁时，必须检查锁是不是自己的, 防止释放别人的锁
            + 判断UUID
        + 检查 value 是否匹配，如果匹配才删除
            + 需要原子操作
                + Lua脚本
    + 幂等性
        + 让锁的持有者可以识别自己的锁，防止重复加锁
            + 把 value1 设置为全局唯一ID
        + 第一次加锁 timeout时，先获取key1的value1
            + 如果key1不存在，重新加锁
            + 如果返回的value1和携带的UUID相同，加锁成功，重新设置过期时间
            + 如果UUID不同，加锁失败
    + 锁过期与续约
        + 设置TTL,防止锁无法释放(业务服务器挂了，无法释放锁)
            + 锁（SETNX）和设置过期时间（EXPIRE）必须是一个原子操作
        + 锁续约（Renewal）机制/watchdog机制
            + 客户端在加锁成功后，启动一个后台线程（或定时任务）
                + 这个线程会周期性地检查客户端是否还持有锁
                + 如果还持有（即业务尚未执行完），就去“续”一下锁的过期时间，比如重新 EXPIRE lock_key 60
            + 续约失败策略
                + 中断业务，抛出异常
                    + 如何中断业务
                        + 续约失败时，给业务代码发一个“中断信号”（比如设置一个 volatile 标志位，或者调用线程的 interrupt() 方法）
                        + 业务代码的关键步骤可以检查lock.isInterrupted()
    + RedLock
        + 单实例Redis。
            + 如果这个 Redis 实例宕机了，整个分布式锁服务就瘫痪了。
        + 多数派原则
            + 部署N个实例，如果N/2+1加锁成功，则加锁成功
                + 设置短连接超时时间，防止在挂掉的节点上浪费时间
                + 如果超过半数（例如 5个中的3个）成功，并且总耗时小于锁的有效时间（过期时间 - 加锁耗时），则认为加锁成功。
                + 锁的真正有效时间 = 初始设置的过期时间 - 加锁总耗时。
        

+ 锁的性能优化
    + Singleflight 模式
        + 在高并发下，可能一个服务实例内的几十个线程
        + 针对同一个 key 的加锁请求，在单个实例内部，只允许一个线程去 Redis 竞争分布式锁。其他线程则在本地等待这个代表的结果。

    + 本地锁交接
        + 实例在del lock之前查看实例内部是否有其他线程需要锁，如果有则转移锁凭证UUID

    + 分布式锁替换
        + 数据库乐观锁
        + 一致性哈希负载均衡
            + 对于这种情况：同一个业务请求（如处理订单 order_id=555）可能被负载均衡打到任何一个实例上
                + 通过一致性哈希等手段，将特定ID的请求（如按 order_id 哈希）固定路由到同一个实例上，那么问题就从“分布式”退化成了“单机”

## 分布式事务
+ 类型
    + 数据库间的事务
        + 分库分表引起的
        + 数据库中间件ShardingSphere提供事务保证
    + 跨服务业务层间的事务
        + 微服务架构引起的
        + Seata来解决

+ 强一致性
    + 2PC (数据库)
        + role
            + Coordinator/Participant
        + phase
            + 准备阶段
                + participant开始执行本地事务(修改数据，锁定资源)
                + 写用于后续提交的 Redo 日志和用于回滚的 Undo 日志
                + 不提交
                + 向协调者回复准备就绪（Yes）或无法准备（No）
            + 提交阶段
                + Coordinator根据反馈发Commit or Rollback
        + 故障处理
            + 故障发生在第一阶段，直接Rollback
            + 发生在第二阶段
                + 协调者发出了 Commit，但某个参与者没收到
                    + Coordinator不断重试
                + 参与者收到了 Commit，但在执行本地提交前宕机了
                    + 这个参与者节点恢复后，它会去检查自己的本地事务日志。它会发现自己已经完成了“准备”阶段，并且也收到了“Commit”指令，于是它会利用之前记录的 Redo 日志，自动完成事务的提交
        + 特点
            + 同步阻塞
            + Coordinator有单点故障
    + 3PC (数据库)
        + CanCommit阶段
            + 资源和状态是否允许执行此事务
            + 此阶段不会锁定资源
        + PreCommit 阶段
            + 相当于2PC的准备阶段
        + DoCommit 阶段
    + XA 规范 (数据库)
        + 接口标准
        + 定义了事务管理器（TM，即协调者）和资源管理器（RM，即实现了 XA 接口的数据库等参与者）

+ 最终一致性
    + TCC(try confirm cancel) （微服务）
        + 将 2PC 的思想从数据库资源层上移到了业务逻辑层
        + phase
            + Try（尝试执行业务，检查并预留资源）
            + Confirm（确认执行业务，真正使用 Try 阶段预留的资源）
            + Cancel（取消执行业务，释放 Try 阶段预留的资源）
                + try阶段的逆操作(扣掉的库存加回来)
        + try, confirm, cancel三个操作各自都是一个完整的本地事务
            + 可以立即提交
        + 故障处理
            + try阶段出错直接cancel
            + 重试直到成功
                + confirm/cancel操作需要幂等
            + 兜底保障机制
                + 监控 + 告警 + 人工介入
                + 异步校准修复（离线）
                    + 建立一个离线的数据比对程序（如定时 Job），T+1 地扫描数据
                    + 例如： 扫描所有“CONFIRMED”状态超过 5 分钟的订单，去和库存系统比对，一旦发现订单已确认、但库存还处于“LOCKED”状态的数据，就立即执行修复
    + SAGA （微服务）
        + TCC 是先预留，再确认，而 SAGA 则是立即执行，失败后再补偿
        + 一个 SAGA 事务由一系列子事务（Local Transaction）构成。
            + 每个子事务都会立即提交。
            + 如果某个子事务失败了，SAGA 会启动补偿事务（Compensation Transaction
                + 按相反的顺序，把前面已经成功提交的子事务撤销掉。
        + 补偿 vs 回滚
            + 回滚是数据库层面的，利用 Undo Log，事务并未提交
            + 补偿是业务层面的反向操作，原事务已经提交，补偿是一个新的本地事务
        + 故障处理
            + 重试
            + SAGA 框架必须保证补偿操作的最终成功
            + 告警 + 人工介入
        + 特点
            + 支持并发
                + 子事务之间无关联
    + AT(Automatic Transaction)（微服务）
        + Seata中间件提供
        + 自动化的SAGA
            + 在你的本地事务（比如 UPDATE）执行前，中间件会先解析 SQL，查出before的数据快照。
            + 中间件将before快照存为一个 undo_log 记录（写在同一数据库中
            + undo_log 和业务数据的修改是在同一个本地事务里提交的
            + 如果全局事务需要回滚，中间件就会读取 undo_log，自动生成反向 SQL（比如把 UPDATE 再 UPDATE 回去），帮你完成补偿
        + 特点
            + 这种模式对业务的侵入性最小，你几乎不用改代码。但它依赖于数据库（需要 undo_log 表）和 SQL 解析（不支持某些复杂 SQL）
            + TCC，SAGA需要写大量业务代码



## 一致性

## snow flake