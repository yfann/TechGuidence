## 分布式锁
+ 当多个独立进程（服务实例、Worker、系统）可能并发访问同一份业务资源，而它们之间没有共享锁机制时，就需要分布式锁。

+ 支持排他性操作的中间件都可以实现分布式锁
    + Redis
    + ZooKeeper
    + Nacos
    + MySQL

+ Redis实现分布式操作
    + 加锁： SETNX key1=value1 （SETNX, SET if Not eXists）
        + 成功返回1
        + 失败时处理
            + 循环轮询（Spin Lock）
            + 事件监听
                + 加锁失败的client可以订阅 key1的删除事件
                    + Redis pub/sub
                    + keyspace notification
    + 释放锁：DEL key1
        + 释放锁时，必须检查锁是不是自己的, 防止释放别人的锁
            + 判断UUID
        + 检查 value 是否匹配，如果匹配才删除
            + 需要原子操作
                + Lua脚本
    + 幂等性
        + 让锁的持有者可以识别自己的锁，防止重复加锁
            + 把 value1 设置为全局唯一ID
        + 第一次加锁 timeout时，先获取key1的value1
            + 如果key1不存在，重新加锁
            + 如果返回的value1和携带的UUID相同，加锁成功，重新设置过期时间
            + 如果UUID不同，加锁失败
    + 锁过期与续约
        + 设置TTL,防止锁无法释放(业务服务器挂了，无法释放锁)
            + 锁（SETNX）和设置过期时间（EXPIRE）必须是一个原子操作
        + 锁续约（Renewal）机制/watchdog机制
            + 客户端在加锁成功后，启动一个后台线程（或定时任务）
                + 这个线程会周期性地检查客户端是否还持有锁
                + 如果还持有（即业务尚未执行完），就去“续”一下锁的过期时间，比如重新 EXPIRE lock_key 60
            + 续约失败策略
                + 中断业务，抛出异常
                    + 如何中断业务
                        + 续约失败时，给业务代码发一个“中断信号”（比如设置一个 volatile 标志位，或者调用线程的 interrupt() 方法）
                        + 业务代码的关键步骤可以检查lock.isInterrupted()
    + RedLock
        + 单实例Redis。
            + 如果这个 Redis 实例宕机了，整个分布式锁服务就瘫痪了。
        + 多数派原则
            + 部署N个实例，如果N/2+1加锁成功，则加锁成功
                + 设置短连接超时时间，防止在挂掉的节点上浪费时间
                + 如果超过半数（例如 5个中的3个）成功，并且总耗时小于锁的有效时间（过期时间 - 加锁耗时），则认为加锁成功。
                + 锁的真正有效时间 = 初始设置的过期时间 - 加锁总耗时。
        

+ 锁的性能优化
    + Singleflight 模式
        + 在高并发下，可能一个服务实例内的几十个线程
        + 针对同一个 key 的加锁请求，在单个实例内部，只允许一个线程去 Redis 竞争分布式锁。其他线程则在本地等待这个代表的结果。

    + 本地锁交接
        + 实例在del lock之前查看实例内部是否有其他线程需要锁，如果有则转移锁凭证UUID

    + 分布式锁替换
        + 数据库乐观锁
        + 一致性哈希负载均衡
            + 对于这种情况：同一个业务请求（如处理订单 order_id=555）可能被负载均衡打到任何一个实例上
                + 通过一致性哈希等手段，将特定ID的请求（如按 order_id 哈希）固定路由到同一个实例上，那么问题就从“分布式”退化成了“单机”

## 分布式事务
+ 类型
    + 数据库间的事务
        + 分库分表引起的
        + 数据库中间件ShardingSphere提供事务保证
    + 跨服务业务层间的事务
        + 微服务架构引起的
        + Seata来解决

+ 强一致性
    + 2PC
        + role
            + Coordinator/Participant
        + phase
            + 准备阶段
                + participant开始执行本地事务(修改数据，锁定资源)
                + 写用于后续提交的 Redo 日志和用于回滚的 Undo 日志
                + 不提交
                + 向协调者回复准备就绪（Yes）或无法准备（No）
            + 提交阶段
                + Coordinator根据反馈发Commit or Rollback
        + 故障处理
            + 故障发生在第一阶段，直接Rollback
            + 发生在第二阶段
                + 协调者发出了 Commit，但某个参与者没收到
                    + Coordinator不断重试
                + 参与者收到了 Commit，但在执行本地提交前宕机了
                    + 这个参与者节点恢复后，它会去检查自己的本地事务日志。它会发现自己已经完成了“准备”阶段，并且也收到了“Commit”指令，于是它会利用之前记录的 Redo 日志，自动完成事务的提交
        + 特点
            + 同步阻塞
            + Coordinator有单点故障
    + 3PC
        + CanCommit阶段
            + 资源和状态是否允许执行此事务
            + 此阶段不会锁定资源
        + PreCommit 阶段
            + 相当于2PC的准备阶段
        + DoCommit 阶段
    + XA 规范
        + 接口标准
        + 定义了事务管理器（TM，即协调者）和资源管理器（RM，即实现了 XA 接口的数据库等参与者）
        
+ 最终一致性



## 一致性

## snow flake