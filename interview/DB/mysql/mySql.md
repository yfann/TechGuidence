
# mysql 

+ select for update
    + 高并发场景
    + 事物中才会生效
        + COMMIT后释放锁
    + 查询时，查询条件有主键，锁行。否则锁表

+ InnoDB
    + 默认是行锁
    + 

+ 数据库隔离级别

+ 幻读


+ 高并发下，如何安全的修改同一行数据


## 索引
+ InnoDB
    + 支持聚集索引
        + 一般用不可更新的主键
            + 更新主键成本高
    + 自适应哈希索引
        + 当MySQL注意到某些索引值被使用的非常频繁时，会在内存中基于B-Tree所有之上再创建一个哈希索引，这就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置。
+ MyISM
    + 索引都是非聚集索引
        + 叶子节点data存放是数据记录的指针地址

+ 索引下推
    + 在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

+ `explain <sql>`
    + 查看执行计划

+ 索引失效
    + like查询以“%”开头
    + or语句前后没有同时使用索引
    + 组合索引中不是使用第一列索引（不符合最左匹配原则）
    + where条件中类型为字符串的字段没有使用引号引起来
         + 查询where条件数据类型不匹配也无法使用索引，字符串与数字比较不使用索引，因为正则表达式不使用索引，如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描
    + 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效
         + 数据量少
    + 对索引字段进行计算操作、使用函数
         + `where date_format(time, '%Y-%m-%d')`
    + 索引散列值（重复多）不适合建索引，例：性别、状态等字段不适合
+ 不适合加索引
    + 不应该在字段比较长的字段上建立索引，因为会消耗大量的空间
    + 对于频繁更新、插入的字段应该少建立索引，因为在修改和插入之后，数据库会去维护索引，会消耗资源
    + 尽量少在无用字段上建立索引【where条件中用不到的字段】
    + 表记录太少不应该创建索引
    + 数据重复且分布平均的表字段不应该创建索引【选择性太低，例如性别、状态、真假值等字段】
    + 参与列计算的列不适合建索引
        + 可以把`from_unixtime(create_time) = '2014-05-29'`改成`create_time = unix_timestamp('2014-05-29')`



## ref

+ [关"SELECT FOR UPDATE"的一些概念](https://www.huaweicloud.com/articles/2941282344610781fd8418a7947a027d.html)
+ [如何理解Mysql索引以及它的底层原理？](https://www.zhihu.com/question/436110377/answer/2951704887)
+ [MySQL索引失效原理是什么](https://www.zhihu.com/question/421944348/answer/2664024847)
