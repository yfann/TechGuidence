# mysql 性能提升

## 读写分离
+ 复制流程
    + 主库更新事件 ( update 、 insert 、 delete ) 通过 io-thread写到 binlog；
    + 从库请求读取 binlog，通过 io-thread 写入从库本地 relay-log（中继日志）；
    + 从库通过 sql-thread 读取 relay-log，并把更新事件在从库中重放（replay）一遍；

## 连接池
+ 连接池是在服务端当中创建多个与数据库的连接
+ 数据库连接池并发提升了数据库的访问性能。同时复用连接，避免连接建立、断开、以及安全验证带来的额外开销。
+ 如果发送一个事务（多个sql语句），那么这个事务必须在一个连接中执行

## 异步连接
+ 连接采用非阻塞IO

## 缓存方案
+ redis + mysql
+ 删除redis当中的数据，然后再写MySQL，最后将MySQL数据同步到redis中（交由 go- mysql-transfer 等中间件处理）
+ mysql同步到redis
    + 伪装数据库
        + 阿里canal
            + Canal可以实时捕获MySQL等数据库中的数据变更，并将这些变更事件传递给redis等缓存数据库，实现数据的实时同步和复制。并且canal会考虑分布式问题，如果一个canal宕机了，会有从canal顶替上来，保证服务正常提供。
        + go-mysql-transfer
            + go-mysql-transfer是一个基于Go语言开发的数据库变更数据传输工具，它可以实时捕获MySQL数据库中的数据变更，并将变更事件传输到给redis等缓存数据库。go-mysql-transfer只有一个节点，相对canal简单些，没有解决分布式问题

    + 触发器+udf(User-defined function)
        + 把热点数据表设置触发器，在触发器中调用 udf，udf 与 redis 建立连接，进行数据同步。udf全称User-defined function，是MySQL提供的一种可扩展代码。UDF不具备事务，不能回滚。总体而言这种方法效率较低，不建议。


## 分库
+ 不能使用join
+ 不能使用事物


## 分表
+ 垂直分割
+ 水平分割
    + 路由
        + 范围路由
            + 1 ~ 999999放到数据库1的表中，1000000 ~ 1999999放到数据库2的表中，以此类推。
        + Hash路由
        + 配置路由
    + 水平分表后，数据分散在多个表中，如果需要与其他表进行join查询，需要在业务代码或者数据库中间件中进行多次join查询，然后将结果合并。
        + count()相加： 具体做法是在业务代码或者数据库中间件中对每个表进行count()操作，然后将结果相加。这种方式实现简单，缺点就是性能比较低。例如，水平分表后切分为20张表，则要进行20次count(*)操作，如果串行的话，可能需要几秒钟才能得到结果。
        + 记录数表： 具体做法是新建一张表，假如表名为“记录数表”，包含table_name、row_count两个字段，每次插入或者删除子表数据成功后，都更新“记录数表”。

