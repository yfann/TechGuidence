


+ 索引失效
    + like查询以“%”开头
    + or语句前后没有同时使用索引
    + 组合索引中不是使用第一列索引（不符合最左匹配原则）
    + where条件中类型为字符串的字段没有使用引号引起来
         + 查询where条件数据类型不匹配也无法使用索引，字符串与数字比较不使用索引，因为正则表达式不使用索引，如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描
    + 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效
         + 数据量少
    + 对索引字段进行计算操作、使用函数
         + `where date_format(time, '%Y-%m-%d')`
    + 索引散列值（重复多）不适合建索引，例：性别、状态等字段不适合
+ 不适合加索引
    + 不应该在字段比较长的字段上建立索引，因为会消耗大量的空间
    + 对于频繁更新、插入的字段应该少建立索引，因为在修改和插入之后，数据库会去维护索引，会消耗资源
    + 尽量少在无用字段上建立索引【where条件中用不到的字段】
    + 表记录太少不应该创建索引
    + 数据重复且分布平均的表字段不应该创建索引【选择性太低，例如性别、状态、真假值等字段】
        + 为什么性别不适合建索引呢？因为你访问索引需要付出额外的IO开销，你从索引中拿到的只是地址，要想真正访问到数据还是要对表进行一次IO。假如你要从表的100万行数据中取几个数据，那么利用索引迅速定位，访问索引的这IO开销就非常值了。但如果你是从100万行数据中取50万行数据，就比如性别字段，那你相对需要访问50万次索引，再访问50万次表，加起来的开销并不会比直接对表进行一次完整扫描小。
    + 参与列计算的列不适合建索引
        + 可以把`from_unixtime(create_time) = '2014-05-29'`改成`create_time = unix_timestamp('2014-05-29')`