## 分布式锁
+ 单服务器模式
    + 本地锁

+ 集群模式
    + 分布式锁

## redis分布式锁
+ 加锁
     + `SETNX key value`
        + 当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。
+ 解锁
    + `DEL key`
        + 通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁

+ 锁超时
    + `EXPIRE key timeout`
        + 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。



## 问题

<!-- 原子操作 -->
+ 用lua脚本使SETNX和EXPIRE原子化
```lua
if (redis.call('setnx', KEYS[1], ARGV[1]) < 1)
then return 0;
end;
redis.call('expire', KEYS[1], tonumber(ARGV[2]));
return 1;
-- 使用实例
EVAL "if (redis.call('setnx',KEYS[1],ARGV[1]) < 1) then return 0; end; redis.call('expire',KEYS[1],tonumber(ARGV[2])); return 1;" 1 key value 100

```

<!-- 锁误解除 -->
+ 如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。

+ 解决
    + 通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。
```lua

-- 加锁
String uuid = UUID.randomUUID().toString().replaceAll("-","");
SET key uuid NX EX 30
-- 解锁
if (redis.call('get', KEYS[1]) == ARGV[1])
    then return redis.call('del', KEYS[1])
else return 0
end
```

<!-- 超时解锁导致并发 -->
+ 如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。
+ 解决
    + 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。
    + 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间

<!-- 不可重入 -->
+ 当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。

<!-- 无法等待锁释放 -->
+ 上述命令执行都是立即返回的，如果客户端可以等待锁释放就无法使用。
+ 解决
    + 可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率
    + 另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息

## 同时加锁的情况
<!-- 主备切换 -->
+ 主从数据同步有异步和同步两种方式
    + Redis 将指令记录在本地内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一致的状态，一边向主节点反馈同步情况
+ 当主节点挂掉时，从节点会取而代之，但客户端无明显感知。当客户端 A 成功加锁，指令还未同步，此时主节点挂掉，从节点提升为主节点，新的主节点没有锁的数据，当客户端 B 加锁时就会成功。

<!-- 集群脑裂 -->
+ 集群脑裂指因为网络问题，导致 Redis master 节点跟 slave 节点和 sentinel 集群处于不同的网络分区，因为 sentinel 集群无法感知到 master 的存在，所以将 slave 节点提升为 master 节点，此时存在两个不同的 master 节点。Redis Cluster 集群部署方式同理。

## lua在Redis中实现原子性
+ 单线程模型： Redis 是单线程模型的数据库，这意味着 Redis 在同一时间只能执行一个操作。当执行 Lua 脚本时，Redis 会将整个脚本作为一个原子性的操作在单线程中执行，这保证了脚本内部的多个操作也会在同一时间内依次执行，从而实现原子性。

+ 脚本执行期间的锁定： 当执行 Lua 脚本时，Redis 会在脚本执行期间锁定数据库，阻止其他客户端的操作。这确保了脚本在执行过程中不会受到其他操作的干扰，保证了原子性。

+ 事务支持： Redis 提供了事务（Transaction）机制，Lua 脚本也可以被包装在事务中执行。事务中的多个命令或 Lua 脚本会作为一个原子性操作进行提交或回滚，从而保证原子性。

+ 不可中断性： Redis 不会中断一个正在执行的命令，因此在 Lua 脚本执行期间，Redis 会将脚本完整地执行完，保证了操作的不可中断性。

## ref
+ [Redis 分布式锁如何实现](https://www.zhihu.com/question/590226584/answer/3152673612)