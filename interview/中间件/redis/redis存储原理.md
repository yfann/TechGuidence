## redis底层原理
+ Redis 中的数据就是一个个键值对，其中的 key 是字符串对象，而 value 可以是许多类型对象（String、List、Hash 等，后续会讲到）。Redis 使用了一个哈希表「dictht」来保存所有键值对

## 底层结构
+ redisDb
    + 表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针
+ dict
    + 结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用（当哈希冲突率过高时，会触发 rehash 来扩容，后续会详细讲解）；
+ dictht
    + 表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个 dictEntry 的指针；
+ dictEntry
    + 表示哈希表节点的结构，结构里存放了 void * key 和 void * value 指针， *key 指向的是 String 对象，而 *value 则可以指向任意类型对象。key 指针和 value 指针各占 8 个字节。
    + 指向下一个hash冲突的dictEntry，形成链表

## 查找数据
+ 在进行哈希表操作时，首先对 key 进行哈希计算，根据哈希值（对应的是数组的下标）找到对应的槽位（dictEntry），然后遍历该槽位的链表，查找与 key 相同的节点。如果哈希冲突率较低，链表的长度较短，那么整个过程的时间复杂度大约为常数级别，即 O(1)。

## redisObject
+ string
+ list
+ hash
+ set

## rehash
+ 在Redis中，rehash是指当一个哈希表（Hash Table）中的元素数量增加到一定程度时，系统会触发对哈希表的扩容操作，以保证哈希表的负载因子（Load Factor）不会过高。负载因子是指哈希表中元素数量与槽位数量之间的比例。当负载因子过高时，会导致哈希冲突增多，影响查找和插入操作的性能

+ 步骤
    1. 新建哈希表：当需要进行rehash时，Redis会新建一个两倍大小的哈希表，然后将原有哈希表的所有元素逐个重新计算哈希值，然后放入新的哈希表中。
    2. 渐进式rehash：由于哈希表可能包含大量的数据，一次性完成rehash可能会造成性能问题。因此，Redis采用渐进式rehash策略，将rehash过程分为多个步骤，在每个操作（比如插入、删除）完成时执行一部分rehash操作，直到旧表中的所有数据都被搬移到新表。
    3. 线程安全性：Redis的rehash过程是线程安全的，因为它在主线程中执行，并且在渐进式rehash过程中，新表会根据需要逐步替换旧表中的数据，确保数据一致性

+ vs java rehash
    1. 容量翻倍：Java的HashMap在进行rehash时，通常会将容量扩大为原来的两倍。这样的设计可以平衡空间和时间的消耗。
    2. 单线程环境：Java的HashMap的rehash操作通常是在单线程环境下进行的，因此不需要考虑多线程的同步问题。
    3. 链表转红黑树：在Java 8及以后的版本中，HashMap中的桶（bucket）由数组和链表组成。当链表中的元素数量过多时，会将链表转换为红黑树，以提高查找和插入操作的性能。
## ref
+ [Redis 底层数据结构的实现原理是什么？](https://www.zhihu.com/question/484626962/answer/2939438430)