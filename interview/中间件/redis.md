## redis

+ 场景
    + 削峰
    + 热数据
    + 计数器
    + 分布式锁

+ redis与DB一致性

+ 防止缓存击穿和雪崩

+ redis数据结构
    + string, hash, list, set, sortedset

+ redis并发竞争,cas操作

+ redis主从机制原理

+ 线程模型
    + 单线程
    + Reactor模型
    + 避免线程切换

+ 事物  

+ 高性能
    + 内存I/O
    + I/O多路复用
    + 单线程模型

+ Redis保证接口幂等性
    + token

## 高并发（内存处理+多路复用）
+ redis基于内存
    + CPU不是瓶颈，可以用单线程
        + 对于多核CPU可以使用多个redis进程，不使CPU闲置
            + 不同key对应不同redis实例

+ 单线程，节省线程切换时间

+ 多路复用（一个线程处理多个socket连接），可以处理并发的连接
    + 非阻塞IO(epoll)
        + epoll的读,写,关闭,连接都会转换为事件
    + 内部事件框架

## 原子性
+ 并发安全
    + 单线程,请求排队处理

+ 原子命令
    + incr，decr
    + mset,mget


+ 加锁
    + 单机锁
        + mutex
    + 分布式锁
        + setnx
+ watch + MULTI(事务)

## redis事物
+ 不支持回滚
+ 中间命令出错会继续执行
    + 错误只会是语法错误或数据类型错误

## redis value数据结构
+ string
    + 字符串,整数，浮点
    + 缓存数据,计数器
    + 分布式锁
        + SETNX
+ list
    + use
        + 消息队列
        + 时间线
+ Hash
    + use
        + 存对象，实体的属性
        + 用户属性
+ Set
    + use
        + Tags,关注列表

+ Sorted Set
    + 排行榜
    + 时间轴

## tips

+ 多路复用
    + select
    + poll
    + epoll

## interview
<!-- redis vs memcache -->
+ redis 支持list, set, hash, sorted set
    + memcache支持string
+ Redis 支持数据持久化
    + memecache不支持
+ redis原生支持cluster
    + memcached不支持原生cluster
+ redis单线程
    + memecached多线程
<!-- 持久化 -->
+ RDB
    + 默认
    + 体积小，保存频率低，容易丢数据。持久化时会Fork主进程，消耗内存，主进程会继续执行请求。
        + 由子进程将内存中的所有数据写入到一个临时的 RDB 文件中，完成写入操作之后，旧的 RDB 文件会被新的 RDB 文件替换掉。
+ AOF
    + 会将接收到的写命令追加到 AOF 文件的末尾，因此 Redis 只要对 AOF 文件中的命令进行回放，就可以将数据库还原到原先的状态。
    + 持久化频率高，数据可靠性高
    + 没有额外的内存或CPU消耗
<!-- 集群 -->
+ 主从集群
     + 主从集群一般一主多从，主库用来写数据，从库用来读数据。结合哨兵，可以再主库宕机时从新选主，
     + 目的是保证Redis的高可用
+ 分片集群
    + 分片集群是数据分片，我们会让多个Redis节点组成集群，并将16383个插槽分到不同的节点上。存储数据时利用对key做hash运算，得到插槽值后存储到对应的节点即可。因为存储数据面向的是插槽而非节点本身，因此可以做到集群动态伸缩。
    + 目的是让Redis能存储更多数据。
<!-- 事务 -->
+ Redis事务其实是把一系列Redis命令放入队列，然后批量执行，执行过程中不会有其它事务来打断。不过与关系型数据库的事务不同，Redis事务不支持回滚操作，事务中某个命令执行失败，其它命令依然会执行。
    + 为了弥补不能回滚的问题，Redis会在事务入队时就检查命令，如果命令异常则会放弃整个事务。
    + Redis有持久化机制，因为可靠性问题，我们一般使用AOF持久化。事务的所有命令也会写入AOF文件，但是如果在执行EXEC命令之前，Redis已经宕机，则AOF文件中事务不完整。使用 redis-check-aof 程序可以移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。
<!-- 过期策略 -->
+ 删除策略
    + 定时删
    + 懒惰删除
        + 访问key时才判断是否删除
+ 内存淘汰策略
    + 内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。
    + LRU（Latest Recently Used）
+ Redis过期策略包含定期删除和惰性删除两部分。定期删除是在Redis内部有一个定时任务，会定期删除一些过期的key。惰性删除是当用户查询某个Key时，会检查这个Key是否已经过期，如果没过期则返回用户，如果过期则删除。但是这两个策略都无法保证过期key一定删除，漏网之鱼越来越多，还可能导致内存溢出。当发生内存不足问题时，Redis还会做内存回收。内存回收采用LRU策略，就是最近最少使用。其原理就是记录每个Key的最近使用时间，内存回收时，随机抽取一些Key，比较其使用时间，把最老的几个删除。Redis的逻辑是：最近使用过的，很可能再次被使用
<!-- 缓存穿透 -->
+ 其一是把不存在的key设置null值到缓存中。其二是使用布隆过滤器
<!-- 缓存击穿 -->
+ 缓存击穿主要担心的是某个Key过期，更新缓存时引起对数据库的突发高并发访问。因此我们可以在更新缓存时采用互斥锁控制，只允许一个线程去更新缓存，其它线程等待并重新读取缓存。例如Redis的setnx命令就能实现互斥效果。
<!-- 缓存雪崩 -->
+ 解决缓存雪崩问题的关键是让缓存Key的过期时间分散。因此我们可以把数据按照业务分类，然后设置不同过期时间。相同业务类型的key，设置固定时长加随机数。尽可能保证每个Key的过期时间都不相同。另外，Redis宕机也可能导致缓存雪崩，因此我们还要搭建Redis主从集群及哨兵监控，保证Redis的高可用。
<!-- Redis实现分布式锁 -->
+ 分布式锁的条件
    + 多进程互斥
    + 保证锁可以释放
    + 阻塞锁
    + 重入锁
        + 获取锁的代码递归调用时，依然可以获取锁
+ setnx
    + 只有第一次执行会成功，可以实现互斥
        + expire
        + `set key value [NX] [EX time]`
            + 保证setnx和expire命令的原子性
    + 在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。
+ 高可用锁
    + RedLock
    + 5个相互独立的Redis实例
        + client同时向5个实例使用相同的key和随机值获取锁
            + 获取3个则成功获取锁
<!-- 如何实现数据库与缓存数据一致？ -->
+ 本地缓存同步：当前微服务的数据库数据与缓存数据同步，可以直接在数据库修改时加入对Redis的修改逻辑，保证一致。
+ 跨服务缓存同步：服务A调用了服务B，并对查询结果缓存。服务B数据库修改，可以通过MQ通知服务A，服务A修改Redis缓存数据
+ 通用方案：使用Canal框架，伪装成MySQL的salve节点，监听MySQL的binLog变化，然后修改Redis缓存数据


## Redis Hash
+ Ziplist
    + 当哈希中存储的键值对数量较少或值的长度较小时，Redis 会使用压缩列表来保存哈希数据。压缩列表是一种紧凑的、节省内存的数据结构，它通过将多个键值对紧密地存储在一起来减少内存占用。压缩列表适用于存储小型哈希，可以节省内存并提高访问速度。
+ Dict
    + 当哈希中的键值对数量较多或值的长度较大时，Redis 会使用字典来存储哈希数据，以保证高效的查找和存储
    + HashTable
    + 散列冲突处理
        + 使用链地址法来处理散列冲突
+ 整数编码
    + 在哈希中，当值是整数类型时，Redis 会对其进行整数编码，以进一步节省内存。整数编码使用固定长度的存储来表示整数值，从而避免了额外的内存开销。
## tips
+ SETNX
    + SET if Not eXists

## ref
+ [Redis-接口的幂等性之Redis解决方案](https://madridseven.github.io/2019/08/JAVA%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%B9%8BRedis%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/)
+ [Redis如何保证接口的幂等性？](https://cloud.tencent.com/developer/article/1752476)
+ [Redis为什么是单线程、及高并发快的3大原因详解](https://zhuanlan.zhihu.com/p/52600663)
+ [用了redis一定可以保证原子性吗](http://blog.itpub.net/70000438/viewspace-2787785/)
+ [Redis 事务](https://www.runoob.com/redis/redis-transactions.html)
<!-- 队列 -->
+ [Redis适合用来做什么？](https://segmentfault.com/a/1190000015894319)
+ [Redis 消息队列的三种方案（List、Streams、Pub/Sub）](https://www.51cto.com/article/640335.html)
<!-- 面试 -->
+ [一篇汇总企业高频面试题—Redis篇。](https://www.zhihu.com/question/487142301/answer/2781233710)

+ [Redis hash实现详解](https://www.jianshu.com/p/7f53f5e683cf)