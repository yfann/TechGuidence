# async/await

## 异步方法

+ async
```c#
public async Task MyAsyncMethod()
{
    // 异步操作的代码
}
```

+ await
```c#
// 等待异步执行完成
await SomeAsyncOperation();
```
## 不阻塞线程

+ 异步方法的挂起（非线程挂起）
    + 在遇到await Task.Delay(100)时，异步方法会暂时挂起，并让出当前线程的控制权。这里的挂起并不是指线程被挂起或阻塞，而是指异步方法暂时停止执行，并将控制权返回给调用它的线程（主线程）。

    + 当遇到await Task.Delay(100)时，它会创建一个延时任务，该任务会在指定的时间（这里是100毫秒）后完成。然后，异步方法会注册一个回调函数，告诉任务完成后要继续执行下一步。

    + 在挂起期间，异步方法不会占用线程资源，而是让线程可以执行其他任务。这样可以提高程序的并发性和资源利用率。

    + 一旦延时任务完成，异步方法会被唤醒，并继续执行后续的代码。这时，并不是创建新的线程来执行延时操作，而是通过异步机制来实现非阻塞的延时操作。
                
    + 具体来说，当异步方法遇到await Task.Delay(100)时，它会将延时任务交给.NET运行时的任务调度器（Task Scheduler）管理。任务调度器会将延时任务放入等待队列中，并继续执行其他任务。
                
    + 在指定的时间（100毫秒）后，任务调度器会将延时任务标记为完成，并将其添加到就绪队列中。当调度器调度到该任务时，它会通知异步方法继续执行，并返回到原来的线程（主线程）上。
                
    + 总之，异步方法的挂起并不是线程的挂起或阻塞，而是暂时停止执行，并让出当前线程的控制权。在挂起期间，线程可以执行其他任务。异步方法通过异步机制来实现非阻塞的延时操作，让出当前线程的控制权，并在延时任务完成后继续执行。


+ await时主线程的操作
    +  当遇到await关键字时，主线程会暂时挂起（挂起点），这并不会阻塞主线程的执行，而是让出当前线程的控制权，允许主线程去执行其他任务
    + 同时，await关键字会将异步操作交给任务调度器来管理。任务调度器会根据当前的线程池状态和调度策略，将异步操作分配给适当的线程执行

## tips
+ await只能在async方法中使用
    + 是因为异步方法的实质是被编译成一种状态机，以便在异步操作挂起时暂停执行，等待操作完成后继续执行。这种状态机的生成是由编译器自动完成的。
    + 在一个普通（非异步）方法中使用 await 是不合法的，因为这样的方法无法被编译器转换为状态机，也就无法正确地处理异步操作的挂起和恢复。

+ 编译器生成的异步状态机（Compiler-generated asynchronous state machine）
    + 在编译时，C# 编译器会将包含 async/await 的方法转换为状态机


+ async/await
    + 可以在单线程上执行
        + 和多线程无关
    + 不阻塞线程
        + 它通过挂起（suspend）和恢复（resume）线程的方式，实现不阻塞线程的效果


## ref
+ [C#中async/await的线程ID变化情况](https://blog.csdn.net/dzweather/article/details/132818166)