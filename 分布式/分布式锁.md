
# 分布式锁
+ 互斥性
+ 锁超时
+ 可用性
     + 计算型
        + 多个备份点
     + 存储型
        + 准备多个备份点，存储超过半数以上的备份节点；并且具有切换功能，以解决宕机问题
+ 容错性
+ 锁的类型
    + 重入锁
        + 递归锁
    + 公平锁
        + 通过排队来实现，对应的是互斥锁
        + 对于互斥锁，当一个线程尝试获取一个已经被其他线程占有的互斥锁时，该线程会在用户态自旋等待一小段时间。当超过一定时间阈值后，会转入内核态，进入阻塞状态。该线程会被放入阻塞队列中，并引起线程切换。当互斥锁的持有者释放锁时，操作系统会唤醒等待中的线程，从阻塞队列中取出一个线程加入就绪队列，等待CPU调度。
    + 非公平锁
        + 不间断尝试获取锁来实现，对应的是自旋锁
        + 对于自旋锁，当一个线程尝试获取一个已经被其他线程占有的自旋锁时。如果是单处理器，该线程会在一个循环中忙等待，空转CPU直到锁被释放。如果是多处理器系统中，该线程会在循环中忙等待一定时间，如果锁还不可用，则会调用sched_yield()，引起线程切换。自旋等待的线程会切换至非运行状态，并被放入就绪队列，等待CPU调度。


## 常用锁
+ 互斥锁
+ 自旋锁(spinlock)
+ 信号量(mutex)
+ 读写锁
+ 原子变量
+ 内存屏障
+ 条件变量

## 分布式 vs 单机
+ 多进程 vs 多线程

+ 多线程共享内存
    + 可以在内存中标记(锁)

+ 多进程锁需要公共内存
    + redis, Memcache

## 基于数据库的锁
<!-- 基于表主键的分布式锁 -->
+ 表主键唯一，同一时间只有一个进程能插入成功. 相当于获取锁
    + 删除数据相当于释放锁
+ 缺点
    + 数据库是单点，挂掉后业务受影响
    + 锁没有失效时间，删除失败后不会自动释放
    + 只能非阻塞，非重入，非公平
    + 大并发可能会锁表
<!-- 基于表字段做分布式锁 -->
+ MYSQL MVCC
<!-- 基于数据库排它锁 -->
+ 查询语句加`for update`
    + 查询时会给表加排它锁(只有通过索引检索时才会使用行锁)
    + 行锁，表锁不确定

## 基于Redis做分布式锁
+ setnx()
    + SET if Not Exists
    + setnx(key, value)
        + 设置成功返回1
        + key已存在返回0
    + 原子方法

+ expire()
    + 设置key的超时时间

+ 删除key释放锁

## 用zookeeper做分布式锁
+ 临时节点

## ref
+ [分布式锁看这篇就够了](https://zhuanlan.zhihu.com/p/42056183)
+ [聊一聊分布式锁的设计模型聊一聊分布](https://zhuanlan.zhihu.com/p/574807053)
+ [分布式锁概述](https://www.zhihu.com/question/300767410/answer/3118729968)