# 微服务

目的是：
+ 快速迭代
+ 持续交付


## 如何拆分服务

+ 垂直拆分（业务维度）
+ 水平拆分（功能维度）

>例如把Message表拆成1024张表，message属于哪张表要根据messageId/1024计算，所以要得到messageId才能找到对应的表。
>实际场景会有根据productId查找messageId的情况，这时要创建大量的映射表才能关联相应数据。


## 高可用

+ 无状态化（微服务冗余）

>无状态方便扩容，哪台机器都可以处理请求，重启后也一样
>只要加了session就是有状态的(即使在其他机器间做session同步，这是最终一致性，同步过程中不一致)

+ 负载均衡(幂等设计)

>解决重复下单问题  
>在会改变数据的层中做幂等（DA）
>CRUD中 CR天然幂等（create不了重复记录） 
>update中如果是绝对值是幂等的，如果是相对值计算比如`udpate t set count=count+1 ...`是不幂等的  
>互联网中避免不了相对值计算，典型的场景是下单和扣款：  
>扣款（-1000￥）前查订单的状态，更具订单状态执行是否扣款（扣款，修改订单状态在一个事务中）

+ 异步化（超时机制）
+ 服务限流降级熔断（数据复制/缓存/Sharding）
+ 架构拆分

## 分布式事物的一致性问题

+ 分布式事物解决的是最终一致性，CAP BAS理论，把长事物拆成短事物

>例如：扣款，下单，减库存在一个分布式中，如果其他两个本地事物成功，另一个本地事物失败，因为事物已经提交无法回滚，需要补>偿机制(如撤单，退款)

+ 发送消息的正确方式

>因为是在分布式中，下单后要发消息通知扣款和减库存    
>把下单和发消息放在一个事务中不能保证一致性，可以下单回滚了，但消息还是发出了（事务本身产生异常） 
>```java
>try{
>    order.update(...);
>    msgClient.send(msg);
>}
>```
>一般做法是会有张message表，下单和插入message记录在同一个事务中  
>MQ读message表->message放入MQ后->MQ返回ACK->message表中删除已读记录

+ MQ去重（除了kafuka,大多数MQ都不支持去重）

>MQ在读message的过程中，可能会有多条重复记录 
>其他服务（扣款，减库存）在订阅MQ后，要根据ETCD(分布式锁)检查orderID是否存在，来判断操作是否执行过了  
>锁需要CP模型，redis是AP模型不适合做ETCD

+ 错误日志/人工干预




## 微服务架构设计模式

+ 聚合器模式
+ 异步消息设计模式
+ 数据共享设计模式

## tips

+ 协议转换（为了提升性能需要协议转换，网络传输的是JSON，服务内部是Protocol buffers协议，需要在GateWay把JSON转成Protocol Buffers。通用转换，不用解析协议语义如：
在java中`JSON->HashMap<String,Object>`

+ 网络IO(读阻塞多，写阻塞少)

+ 正向代理(客戶端知道代理的存在)，反向代理（客戶端不知道代理的存在）

+ 微服务是一种业务服务

+ CP强一致性，AP最终一致性

+ 数据强一致性（如银行交易系统）不适合微服务，社交场景可以使用微服务

+ push/pull (微博不太适合数据推送，大V有千万粉丝，发一条信息就会推送千万次，造成性能问题。适合数据拉取)

+ Codis基于Redis，方便做Sharding

+ NoSQL sharding可在DB层做，New SQL不用做Sharding了

+ 原来两层为同步架构，中间加了一层Message Queue后就会变为异步架构

>MQ加到离前端越近越好  
>读请求不做异步（当用户使用查询后要立刻返回结果，而不是空白页)  
>写请求如果是数据若一致性可做异步(如社交数据)，强一致性不做异步(如金融数据)

+ 静态数据可以存成文件(csv),这样服务启动时可以直接把文件加到内存中，提升访问速度

+ 尽量不用自增主键，用业务主键



## keywords

+ Protocol Buffers
+ IDC(internet data center) 云以IDC机房为基础
+ IO模型
+ Service Mesh
+ Sharding(分库分表)
+ LAMP架构(Linux-Apache-MySQL-PHP)
+ MQ异步使用
+ VIP(虚拟ip,可以在物理机挂掉后,指向其他物理机)
+ ETCD(分布式锁)